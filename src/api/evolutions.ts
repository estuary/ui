import { DEFAULT_FILTER, insertSupabase, TABLES } from 'services/supabase';
import { hasLength } from 'utils/misc-utils';
import { suggestedName } from 'utils/name-utils';

export type RequiresRecreation =
    // The collection key in the draft differs from that of the live spec.
    | 'keyChange'
    // One or more collection partition fields in the draft differs from that of the live spec.
    | 'partitionChange'
    // A live spec with the same name has already been created and was subsequently deleted.
    | 'prevDeletedSpec'
    // This variant is deprecated and removed from the latest version of the agent. It's retained here
    // only to temporarily ensure compatibility between the agent and the UI, and can be removed once
    // the agent changes make it into production.
    | 'authoritativeSourceSchema';

export interface AffectedMaterialization {
    name: string;
    fields: {
        field: string;
        reason: string;
    }[];
}

// Evolution starts by the publish returning this object in job_status['incompatible_collections']
export interface IncompatibleCollections {
    collection: string;
    requires_recreation: RequiresRecreation[];
    affected_materializations?: AffectedMaterialization[];
}

// Creates an EvolutionRequest from an IncompatibleCollection. This will automatically choose whether to
// re-create the collection, based on the values of `requires_recreation`. If a new collection is to be
// created, the `new_name` will be generated by appending a _v2 suffix or incrementing an existing one.
export function toEvolutionRequest(
    ic: IncompatibleCollections
): EvolutionRequest {
    const req: EvolutionRequest = { current_name: ic.collection };
    if (hasLength(ic.requires_recreation)) {
        req.new_name = suggestedName(ic.collection);
    } else if (ic.affected_materializations) {
        // since we're _not_ re-creating the collection, restrict the evolution to only apply to
        // the materializations that were affected.
        req.materializations = ic.affected_materializations.map((m) => m.name);
    }
    return req;
}

// TODO (schema evolution) we do not use this response yet as we do not manually check
//  or display any information to the user about which things were updated.
// Evolution success will return this object in job_status['evolved_collections']
export interface EvolvedCollections {
    new_name: string;
    old_name: string;
    updated_captures: string[];
    updated_materializations: string[];
}

// Represents the shape fo the inputs to the evolutions table.
export interface EvolutionRequest {
    // The current (live) collection name. This is always required.
    current_name: string;
    // If the desired action is to re-create the collection, then this field should be set to the new name.
    // Otherwise, the evolution will only update materialization bindings to materialize into new resources.
    new_name?: string;
    // If specified, restrict the evolution to only the given materializations.
    // At most one of `new_name` or `materializations` may be specified, since
    // re-creating the collection must apply to all materializations.
    materializations?: string[];
}

export const createEvolution = (
    draftId: string | null,
    collections: EvolutionRequest[]
) => {
    return insertSupabase(TABLES.EVOLUTIONS, {
        draft_id: draftId ?? DEFAULT_FILTER,
        collections,
    });
};
