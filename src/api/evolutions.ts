import type {
    IncompatibleCollections,
    ValidHelpMessageId,
} from 'src/components/shared/Entity/IncompatibleCollections/types';

import { DEFAULT_FILTER } from 'src/services/shared';
import { insertSupabase, TABLES } from 'src/services/supabase';
import { hasLength } from 'src/utils/misc-utils';

// Creates an EvolutionRequest from an IncompatibleCollection. This will automatically choose whether to
// re-create the collection, based on the values of `requires_recreation`. If a new collection is to be
// created, the `new_name` will be generated by appending a _v2 suffix or incrementing an existing one.
export function toEvolutionRequest(
    ic: IncompatibleCollections
): EvolutionRequest {
    const req: EvolutionRequest = { current_name: ic.collection };

    if (hasLength(ic.requires_recreation)) {
        req.reset = true;
    } else if (ic.affected_materializations) {
        // since we're _not_ re-creating the collection, restrict the evolution to only apply to
        // the materializations that were affected.
        req.materializations = ic.affected_materializations.map((m) => m.name);
    }

    // if somehow there is no requires_recreations AND affected_materializations then we just pass
    // a request of {"current_name": "a/b"}, and the evolutions handler will figure out which
    // materializations to update (as of Q2 2025)

    return req;
}

export const getEvolutionMessageId = (
    evolutionRequest: EvolutionRequest
): ValidHelpMessageId => {
    if (evolutionRequest.reset) {
        return 'resetCollection';
    }

    return 'fallThrough';
};

// Represents the shape fo the inputs to the evolutions table.
export interface EvolutionRequest {
    // The current (live) collection name. This is always required.
    current_name: string;
    // If the desired action is to re-create the collection, then this field should be set to the new name.
    // Otherwise, the evolution will only update materialization bindings to materialize into new resources.
    new_name?: string;
    // If specified, restrict the evolution to only the given materializations.
    // At most one of `new_name` or `materializations` may be specified, since
    // re-creating the collection must apply to all materializations.
    materializations?: string[];

    // This triggers the backend to kick off `Collection Reset` and do a full proper backfill
    reset?: boolean;
}

export const createEvolution = (
    draftId: string | null,
    collections: EvolutionRequest[]
) => {
    return insertSupabase(TABLES.EVOLUTIONS, {
        draft_id: draftId ?? DEFAULT_FILTER,
        collections,
    });
};
